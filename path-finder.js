// Generated by CoffeeScript 1.7.1
(function() {
  var PathFinder, compact, dump, estimate, find, findIndex, isGoal, passable, pow, resolvePath, searchDirections, searchPassableNodes, searchPath, shiftMinCostNode;

  find = function(arr, fn) {
    var i, _i, _len;
    for (_i = 0, _len = arr.length; _i < _len; _i++) {
      i = arr[_i];
      if (fn(i)) {
        return i;
      }
    }
  };

  findIndex = function(arr, fn) {
    var i, index, _i, _len;
    for (index = _i = 0, _len = arr.length; _i < _len; index = ++_i) {
      i = arr[index];
      if (fn(i)) {
        return index;
      }
    }
  };

  compact = function(arr) {
    return arr.filter(function(i) {
      return i != null;
    });
  };

  pow = Math.pow;

  dump = function(hitmap) {
    var row, _i, _len, _results;
    _results = [];
    for (_i = 0, _len = hitmap.length; _i < _len; _i++) {
      row = hitmap[_i];
      _results.push(console.log(row.map(function(v) {
        if (v) {
          return '**';
        } else {
          return '  ';
        }
      }).join('')));
    }
    return _results;
  };

  searchDirections = [[0, -1], [-1, 0], [+1, 0], [0, 1]];

  passable = function(v) {
    return v === 0;
  };

  searchPassableNodes = function(hitmap, _arg, goal) {
    var cx, cy;
    cx = _arg[0], cy = _arg[1];
    return compact(searchDirections.map(function(_arg1) {
      var dx, dy;
      dx = _arg1[0], dy = _arg1[1];
      if (passable(hitmap[cx + dx][cy + dy])) {
        return [cx + dx, cy + dy, estimate([cx + dx, cy + dy], goal)];
      } else {
        return null;
      }
    }));
  };

  isGoal = function(current, goal) {
    return estimate(current, goal) === 0;
  };

  shiftMinCostNode = function(nodes) {
    var minCost, minIndex, p, _ref;
    if (nodes.length === 0) {
      return null;
    }
    _ref = nodes.reduce((function(_arg, _arg1, index) {
      var cost, minCost, minIndex, x, y;
      minCost = _arg[0], minIndex = _arg[1];
      x = _arg1[0], y = _arg1[1], cost = _arg1[2];
      if (minCost < cost) {
        return [minCost, minIndex];
      } else {
        return [cost, index];
      }
    }), Infinity), minCost = _ref[0], minIndex = _ref[1];
    p = nodes.splice(minIndex, 1)[0];
    return p;
  };

  resolvePath = function(node) {
    var cost, nx, ny, parent, path, x, y;
    x = node[0], y = node[1], cost = node[2], parent = node[3];
    path = [[x, y]];
    while (node = node[3]) {
      nx = node[0], ny = node[1];
      path.push([nx, ny]);
    }
    return path.reverse();
  };

  searchPath = function(hitmap, start, goal, maxDepth) {
    var cCost, closeNodes, cnt, cost, currentCost, currentParent, currentX, currentY, cx, cy, index, next, nextNodes, node, oCost, openNodes, ox, oy, x, y, _i, _len, _ref, _ref1;
    if (maxDepth == null) {
      maxDepth = Infinity;
    }
    currentCost = estimate(start, goal);
    if (currentCost === 0) {
      return [];
    }
    currentX = start[0], currentY = start[1];
    openNodes = [[currentX, currentY, currentCost]];
    closeNodes = [];
    cnt = 0;
    while (node = shiftMinCostNode(openNodes)) {
      if (++cnt >= maxDepth) {
        return null;
      }
      currentX = node[0], currentY = node[1], currentCost = node[2], currentParent = node[3];
      if (currentCost === 0) {
        return resolvePath(node);
      }
      closeNodes.push(node);
      nextNodes = searchPassableNodes(hitmap, [currentX, currentY], goal);
      for (_i = 0, _len = nextNodes.length; _i < _len; _i++) {
        next = nextNodes[_i];
        x = next[0], y = next[1], cost = next[2];
        if ((index = findIndex(openNodes, function(_arg) {
          var ox, oy;
          ox = _arg[0], oy = _arg[1];
          return x === ox && y === oy;
        })) > -1) {
          _ref = openNodes[index], ox = _ref[0], oy = _ref[1], oCost = _ref[2];
          if (oCost > cost) {
            openNodes[index] = [x, y, cost, node];
          }
        } else if ((index = findIndex(closeNodes, function(_arg) {
          var cx, cy;
          cx = _arg[0], cy = _arg[1];
          return x === cx && y === cy;
        })) > -1) {
          _ref1 = closeNodes[index], cx = _ref1[0], cy = _ref1[1], cCost = _ref1[2];
          if (cCost > cost) {
            closeNodes.splice(index, 1);
            openNodes.push([cx, cy, cost, node]);
          }
        } else {
          openNodes.push([x, y, cost, node]);
        }
      }
    }
  };

  estimate = function(_arg, _arg1) {
    var x1, x2, y1, y2;
    x1 = _arg[0], y1 = _arg[1];
    x2 = _arg1[0], y2 = _arg1[1];
    return pow(x1 - x2, 2) + pow(y1 - y2, 2);
  };

  PathFinder = (function() {
    function PathFinder(options) {
      var _ref, _ref1, _ref2, _ref3;
      if (options == null) {
        options = {};
      }
      this.estimate = (_ref = options.estimate) != null ? _ref : estimate;
      this.maxDepth = (_ref1 = options.maxDepth) != null ? _ref1 : Infinity;
      this.passable = (_ref2 = options.passable) != null ? _ref2 : passable;
      this.searchDirections = (_ref3 = options.searchDirections) != null ? _ref3 : searchDirections;
    }

    PathFinder.dumpHitmap = function(hitmap) {
      return dump(hitmap);
    };

    PathFinder.prototype.searchPath = function(hitmap, from, to) {
      return searchPath.call(this, hitmap, from, to, this.maxDepth);
    };

    return PathFinder;

  })();

  if (typeof module !== "undefined" && module !== null ? module.exports : void 0) {
    module.exports = PathFinder;
  } else {
    window.PathFinder = PathFinder;
  }

}).call(this);
